/* Generated By:JavaCC: Do not edit this line. Atroem.java */
    import java.util.*;

        public class Atroem implements AtroemConstants {
        private boolean bandera = false;
        private static ArrayList<String> mensajesError = new ArrayList();
        private static ArrayList<Integer> tipoVar = new ArrayList();
        private static ArrayList<String> nombreVar = new ArrayList();
        private static ArrayList<String> valorVar = new ArrayList();
                public static void main(String[]args)throws TokenMgrError{

                        try{
                                Atroem analizador = new Atroem(System.in);
                                analizador.Inicio();

                if(!mensajesError.isEmpty()){
                    System.out.println("\nErrores encontrados: "+mensajesError.size());
                                    for(String mensaje:mensajesError){
                          System.out.println(mensaje);
                       }
                       System.out.println("\nVerifique tabla de errores");
                }else{
                    System.out.println("\nErrores encontrados: "+mensajesError.size());
                    System.out.println("\n-----Compilaci\u00c3\u00b3n exitosa-----\n");
                    }

                        }catch(ParseException e){
                                System.out.println(e.getMessage());
                        }//catch(TokenMgrError e){
                                //System.out.println(e.getMessage()+"aqui");
                //}

                }

/*Funciones*/
  static final public void Inicio() throws ParseException {
    try {
      Progr();
      Nprograma();
      Llai();
      Principal();
      Llad();
      Finprogr();
      jj_consume_token(0);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void Principal() throws ParseException {
    try {
      Main();
      Llai();
      Sentencias();
      Llad();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {

    }
  }

  static final public void Sentencias() throws ParseException {
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ENTERO:
        case DECIMAL:
        case CARACTER:
        case CADE:
        case BOOLEANO:
        case SI:
        case OPCION:
        case FOR:
        case WHILE:
        case DO:
        case ENTRADA:
        case SALIDA:
        case VARIABLE:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ENTERO:
        case DECIMAL:
        case CARACTER:
        case CADE:
        case BOOLEANO:
          Declaracion();
          break;
        case VARIABLE:
          Asignacion();
          break;
        case FOR:
          For();
          break;
        case WHILE:
          While();
          break;
        case DO:
          DoWhile();
          break;
        case SI:
          If();
          break;
        case OPCION:
          Switch();
          break;
        case ENTRADA:
          Entrada();
          break;
        case SALIDA:
          Salida();
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
       mensajesError.add(ex.getMessage());
    }
  }

  static final public void Declaracion() throws ParseException {
 int indice;
    try {
      TipoDeDato();
      guardarTipo();
      Variable();
      guardarIden();
      guardarValor();
                                                                       indice = buscarVar();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PUCOMA:
        Pucoma();
        break;
      case ASIGNAR:
        AsignacionDec(indice);
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void Asignacion() throws ParseException {
    int indice;
    try {
      Variable();
                   indice = buscarVar();
      AsignacionDec(indice);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    } catch (IndexOutOfBoundsException exc) {
         mensajesError.add("\n\nLa variable: " + token.image + " no existe");
    }
  }

  static final public void AsignacionDec(int indice) throws ParseException {
    ArrayList<String> expresion = new ArrayList();
    try {
      Asignar();
      ValorGeneral();
      comprobarAsig(indice);
                                            expresion.add(token.image);
         if(tipoVar.get(indice) == 35 || tipoVar.get(indice) == 36)
        operacion(indice, expresion);
      Pucoma();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
     valorVar.set(indice, comprobarTipo(indice, generarValor(conversionPrefija(expresion))));
  }

  static final public ArrayList<String> operacion(int indice, ArrayList<String> expresion) throws ParseException {
    try {
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SUMA:
        case RESTA:
        case MULTI:
        case DIVISION:
        case RESIDUO:
        case POTENCIA:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        OperadorAri();
                       expresion.add(token.image);
        ValorNum();
        comprobarAsig(indice);
                                        expresion.add(token.image);
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
         {if (true) return expresion;}
    throw new Error("Missing return statement in function");
  }

  static void hastaPucoma() throws ParseException {
    Token t;

    while(true){
        t = getToken(1);
        if(t.kind == 17){
            t = getNextToken();
            break;
        }
        t = getNextToken();
    }
  }

  static String comprobarTipo(int indice, String r) throws ParseException {
    if(tipoVar.get(indice) == 35){

            float resultado = Float.parseFloat(r);
            int aux = (int)resultado;
            return String.valueOf(aux);
    }else{
        return r;
    }
  }

  static void comprobarAsig(int indice) throws ParseException {
    int tokenIndice=0;
    try{
        if(token.kind == 52){
            tokenIndice = tipoVar.get(buscarVar());
        }else{
            tokenIndice = token.kind;
        }
    }catch(IndexOutOfBoundsException exc){
         mensajesError.add("\n\nLa variable: " + token.image + " no existe");
    }

    switch(tipoVar.get(indice)){
        //Entero
        case 35:{
            if(tokenIndice == 53 || tokenIndice == 35){
            }else{
                regErrorTipoVAr(token, "Valor entero");
            }
            break;
        }
        //Decimal
        case 36:{
            if(tokenIndice == 54 || tokenIndice == 36){
            }else{
                regErrorTipoVAr(token, "Valor decimal");
            }
            break;
        }
        //Caracter
        case 37:{
            if(tokenIndice == 55 || tokenIndice == 37){
            }else{
                regErrorTipoVAr(token, "Caracter");
            }
            break;
        }
        //Cadena
         case 38:{
            if(tokenIndice == 56 || tokenIndice == 38){
            }else{
                regErrorTipoVAr(token, "Valor de cadena");
            }
            break;
        }
        //Boleano
        case 39:{
            if(tokenIndice == 5 || tokenIndice == 6  || tokenIndice == 39){
            }else{
                regErrorTipoVAr(token, "Valor booleano");
            }
            break;
        }
    }
  }

  static void guardarTipo() throws ParseException {
    tipoVar.add(token.kind);
  }

  static void guardarIden() throws ParseException {
    nombreVar.add(token.toString());
  }

  static void guardarValor() throws ParseException {
    valorVar.add("0");
  }

  static int buscarVar() throws ParseException {
    Token t = token;
    int indice = -1;

    for(int i=0; i < nombreVar.size(); i++){
        if(nombreVar.get(i).equals(t.image)){
            indice = i;
            //System.out.println("Indice: " + indice);
            break;
        }
    }

    return indice;
  }

  static int buscarVarOperacion(String operando) throws ParseException {
    int indice = -1;
    for(int i=0; i < nombreVar.size(); i++){
        if(nombreVar.get(i).equals(operando)){
            indice = i;
            break;
        }
    }

    return indice;
  }

  static ArrayList conversionPrefija(ArrayList<String> a) throws ParseException {
    Stack<String> pilaOperadores = new Stack<String>();
    Stack<String> exPrefija = new Stack<String>();
    String expresionPrefija = "";

    while(!a.isEmpty()){
        String elemento = a.get(a.size()-1);
        if(esOperador(elemento)){
                while(!pilaOperadores.empty() && comprobarPrioridad(elemento, pilaOperadores.peek())){
                    exPrefija.push(pilaOperadores.pop());
                }
                pilaOperadores.push(elemento);
        }else{
            exPrefija.push(elemento);
        }

        a.remove(a.size()-1);
    }


    while(!pilaOperadores.empty()){
        exPrefija.push(pilaOperadores.pop());
    }

    ArrayList<String> exInvertida = new ArrayList<String>();
    while(!exPrefija.empty()){
        exInvertida.add(exPrefija.pop());
    }

    //Imprime la expresión prefija
    /*for(int i=0; i<exInvertida.size(); i++){
        System.out.print(exInvertida.get(i) + " ");
    }
        System.out.println("");*/
    return exInvertida;
  }

  static boolean esOperador(String c) throws ParseException {
    return (c == "+" || c == "-" || c == "*" || c == "/" || c== "=");
  }

  static boolean comprobarPrioridad(String op1, String op2) throws ParseException {
    switch (op1) {
        case "+":
        case "-":
        case "=":
            return true;
        case "*":
        case "/":
            return (op2 == "*" || op2 == "/" ? true : false);
    }
    return true;
  }

  static String generarValor(ArrayList<String> expresion) throws ParseException {
    while(expresion.size() > 1){
        for(int i=0; i<expresion.size();i++){
            if(esOperador(expresion.get(i))){
                if(!esOperador(expresion.get(i+1)) && !esOperador(expresion.get(i+2))){
                    expresion.set(i, imprimirValor(expresion.get(i+1), expresion.get(i+2), expresion.get(i)));
                    expresion.remove(i+2);
                    expresion.remove(i+1);
                    break;
                }
            }
        }
    }
    return expresion.get(0);
  }

  static String imprimirValor(String a, String b, String op) throws ParseException {
    float operandoA=0, operandoB=0, resultado = 0;

    try{
        if(a.contains("$")){
            a = valorVar.get(buscarVarOperacion(a));
        }
        operandoA = Float.parseFloat(a);
    }catch(IndexOutOfBoundsException exc){
        System.out.println("La variable "+a+" no existe");
        return resultado + "";
    }

    try{
        if(b.contains("$")){
            b = valorVar.get(buscarVarOperacion(b));
        }
        operandoB = Float.parseFloat(b);
    }catch(IndexOutOfBoundsException exc){
        System.out.println("La variable "+b+" no existe");
        return resultado + "";
    }

    switch(op){
        case "+":{
            resultado = operandoA + operandoB;
            break;
        }
        case "-":{
            resultado = operandoA - operandoB;
            break;
        }
        case "*":{
            resultado = operandoA * operandoB;
            break;
        }
        case "/":{
            resultado = operandoA / operandoB;
            break;
        }
    }
    /*String[] aux = String.valueOf(resultado).split(".");
    if(a.contains(".") || b.contains(".") || !aux[1].equals("0")){
        return String.valueOf(resultado);
    }else{
        return String.valueOf(Math.roundFloor(resultado));
    }*/

    return resultado + "";
  }

  static void regErrorTipoVAr(Token tokenActual, String tokenEsperado) throws ParseException {
    String retval = "\n\nAnalizador: Ocurri\u00c3\u00b3 un error sem\u00c3\u00a1ntico de tipo de variable\n";
    retval += "Se encontr\u00c3\u00b3 ( ";
    retval += tokenActual.image;
    retval += " ) en la l\u00c3\u00adnea " + tokenActual.beginLine + ", columna " + tokenActual.beginColumn;
    retval += ".\nEra esperado un "+tokenEsperado+".";
    mensajesError.add(retval);
  }

  static final public void For() throws ParseException {
    try {
      For1();
      Pari();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ENTERO:
      case DECIMAL:
        TipoDeDatoNumerico();
        Variable();
        break;
      case VARIABLE:
        Variable();
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Asignar();
      Valor();
      Pucoma();
      Variable();
      OperadorComparacion();
      Valor();
      Pucoma();
      Variable();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INC:
      case DEC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INC:
          Inc();
          break;
        case DEC:
          Dec();
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case ASIGNAR:
        Asignar();
        Variable();
        OperadorAri();
        ValorNum();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      Pard();
      Llai();
      Sentencias();
      Llad();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void While() throws ParseException {
    try {
      While1();
      Pari();
      Comparacion();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPY:
        case OPO:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPY:
          Opy();
          break;
        case OPO:
          Opo();
          break;
        default:
          jj_la1[8] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Comparacion();
      }
      Pard();
      Llai();
      Sentencias();
      Llad();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void DoWhile() throws ParseException {
    try {
      Do();
      Llai();
      Sentencias();
      Llad();
      While();
      Pari();
      Comparacion();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPY:
        case OPO:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_4;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPY:
          Opy();
          break;
        case OPO:
          Opo();
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Comparacion();
      }
      Pard();
      Pucoma();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void If() throws ParseException {
    int resComp = 0;
    try {
      Si();
      Pari();
         resComp = Comparacion();
      Pard();
      Llai();
      Sentencias();
      Llad();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NOSI:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_5;
        }
        ElseIf();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SINO:
        Else();
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

/*void Comparacion():{}{
    try{
        ValorGeneral()OperadorComparacion()ValorGeneral()
    }catch(ParseException e){
        mensajesError.add(e.getMessage());
    }catch(TokenMgrError ex){
        mensajesError.add(ex.getMessage());
    }
}*/
  static final public int Comparacion() throws ParseException {
    String opA = "", opB = "", op = "", bool = "";
    int kopA = 0, kopB = 0, kop = 0, kbool = 0;
    int resComp = 0;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
      case FALSE:
        ValorBooleano();
                         resComp = comprobarBooleano(token.image, token.kind);
        break;
      case RESTA:
      case VARIABLE:
      case NUMERO:
      case NUMERODEC:
      case CARAC:
      case CADENA:
        Valor();
                 opA = token.image; kopA = token.kind;
        OperadorComparacion();
                              op = token.image; kop = token.kind;
        Valor();
                opB = token.image; kopB = token.kind;
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
     resComp = comparacionDato(opA, opB, op, kopA, kopB, kop);
    {if (true) return resComp;}
    throw new Error("Missing return statement in function");
  }

  static int comprobarBooleano(String bool, int kindBool) throws ParseException {
    if(kindBool == 52){
        int indice = buscarVarIndice(bool);
        if(indice == -1) return 0;
        bool = valorVar.get(indice);
    }
    if(bool.equals("verdadero")) return 1; else return 0;
  }

  static int comparacionDato(String opA, String opB, String op, int kopA, int kopB, int kop) throws ParseException {
    if(kopA == 52){
        int indice = buscarVarIndice(opA);
        if(indice == -1) return 0;
        kopA = tipoVar.get(indice);
        opA = valorVar.get(indice);
    }
    if(kopB == 52){
        int indice = buscarVarIndice(opB);
        if(indice == -1) return 0;
        kopB = tipoVar.get(indice);
        opB = valorVar.get(indice);
    }

    //Cadena
    if(kopA == 55 && kopB == 55 && kop == 11){
        if(opA.equals(opB)) return 1; else return 0;
    }
    //Caracter
    if(kopA == 56 && kopB == 56 && kop == 11){
        if(opA.equals(opB)) return 1; else return 0;
    }

    //Enteros
    if(kopA == 53 && kopB == 53){
        int a = Integer.parseInt(opA);
        int b = Integer.parseInt(opB);
        switch(kop){
            case 9:{
                if(a < b) return 1; else return 0;
            }
            case 10:{
                if(a > b) return 1; else return 0;
            }
            case 11:{
                if(a == b) return 1; else return 0;
            }
            case 12:{
                if(a != b) return 1; else return 0;
            }
            case 15:{
                if(a <= b) return 1; else return 0;
            }
            case 16:{
                if(a >= b) return 1; else return 0;
            }
        }
    }

    //Decimales
    if(kopA == 54 && kopB == 54){
        float a = Float.parseFloat(opA);
        float b = Float.parseFloat(opB);
        switch(kop){
            case 9:{
                if(a < b) return 1; else return 0;
            }
            case 10:{
                if(a > b) return 1; else return 0;
            }
            case 11:{
                if(a == b) return 1; else return 0;
            }
            case 12:{
                if(a != b) return 1; else return 0;
            }
            case 15:{
                if(a <= b) return 1; else return 0;
            }
            case 16:{
                if(a >= b) return 1; else return 0;
            }
        }
    }
    return 0;
  }

  static int buscarVarIndice(String nomVar) throws ParseException {
    try{
        for(int i=0; i < nombreVar.size(); i++){
            if(nombreVar.get(i).equals(nomVar)){
                return i;
            }
        }
    }catch(IndexOutOfBoundsException exc){
        System.out.println("La variable "+nomVar+" no existe");
    }
    return -1;
  }

  static final public void OperadorComparacion() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MENOR:
        Menor();
        break;
      case MAYOR:
        Mayor();
        break;
      case IGUAL:
        Igual();
        break;
      case MENORIGUAL:
        Menorigual();
        break;
      case MAYORIGUAL:
        Mayorigual();
        break;
      case DIFERENTEDE:
        Diferentede();
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void Else() throws ParseException {
    try {
      Sino();
      Llai();
      Sentencias();
      Llad();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void ElseIf() throws ParseException {
    try {
      Nosi();
      Pari();
      Comparacion();
      Pard();
      Llai();
      Sentencias();
      Llad();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void Switch() throws ParseException {
    try {
      Opcion();
      Pari();
      Variable();
      Pard();
      Llai();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASO:
          ;
          break;
        default:
          jj_la1[15] = jj_gen;
          break label_6;
        }
        Caso();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PORDEFECTO:
        PorDefecto();
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      Llad();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void Caso() throws ParseException {
    try {
      Caso1();
      ValorCaso();
      Dpuntos();
      Llai();
      Sentencias();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTERRUMPIR:
        Interrumpir();
        Pucoma();
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      Llad();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void PorDefecto() throws ParseException {
    try {
      Pordefecto();
      Dpuntos();
      Llai();
      Sentencias();
      Llad();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

//ENTRADA Y SALIDA
  static final public void Entrada() throws ParseException {
    try {
      Entrada1();
      Pari();
      TipoDeDato();
      Pard();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void imprimirSalida(String mensaje) throws ParseException {
        mensaje = mensaje.replaceAll("\"","");
        mensaje = mensaje.replaceAll("\'","");
        System.out.println(mensaje);
  }

  static final public void Salida() throws ParseException {
    ArrayList<String> expImprimir = new ArrayList();
    String eFinal = "";
    try {
      Salida1();
      Pari();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CADENA:
        Cadena();
                                     expImprimir.add(token.image);
        break;
      case VARIABLE:
        Variable();
                                                                               expImprimir.add(valorVar.get(buscarVar()));
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMA:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_7;
        }
        Coma();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VARIABLE:
          Variable();
                    expImprimir.add(valorVar.get(buscarVar()));
          break;
        case CADENA:
          Cadena();
                                                                          expImprimir.add(token.image);
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      Pard();
      Pucoma();
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    } catch (IndexOutOfBoundsException exc) {
        System.out.println("La variable No ha sido declarada");
    }
    try {
         for(int i=0; i<expImprimir.size(); i++){
        eFinal = eFinal + expImprimir.get(i);}
    } catch (IndexOutOfBoundsException exc) {

    }
    imprimirSalida(eFinal);
  }

  static final public void TipoDeDatoNumerico() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ENTERO:
        Entero();
        break;
      case DECIMAL:
        Decimal();
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void TipoDeDato() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ENTERO:
        Entero();
        break;
      case DECIMAL:
        Decimal();
        break;
      case CARACTER:
        Caracter();
        break;
      case CADE:
        Cade();
        break;
      case BOOLEANO:
        Booleano();
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void Valor() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE:
        Variable();
        break;
      case RESTA:
      case NUMERO:
      case NUMERODEC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESTA:
          Resta();
          break;
        default:
          jj_la1[23] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUMERO:
          Numero();
          break;
        case NUMERODEC:
          Numerodec();
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case CADENA:
        Cadena();
        break;
      case CARAC:
        Carac();
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void ValorNum() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE:
        Variable();
        break;
      case RESTA:
      case NUMERO:
      case NUMERODEC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESTA:
          Resta();
          break;
        default:
          jj_la1[26] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUMERO:
          Numero();
          break;
        case NUMERODEC:
          Numerodec();
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void ValorGeneral() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE:
        Variable();
        break;
      case RESTA:
      case NUMERO:
      case NUMERODEC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESTA:
          Resta();
          break;
        default:
          jj_la1[29] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUMERO:
          Numero();
          break;
        case NUMERODEC:
          Numerodec();
          break;
        default:
          jj_la1[30] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case CADENA:
        Cadena();
        break;
      case CARAC:
        Carac();
        break;
      case TRUE:
      case FALSE:
      case NEGACION:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEGACION:
          Negacion();
          break;
        default:
          jj_la1[31] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TRUE:
          True();
          break;
        case FALSE:
          False();
          break;
        default:
          jj_la1[32] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void ValorCaso() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RESTA:
      case NUMERO:
      case NUMERODEC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESTA:
          Resta();
          break;
        default:
          jj_la1[34] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUMERO:
          Numero();
          break;
        case NUMERODEC:
          Numerodec();
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case CADENA:
        Cadena();
        break;
      case CARAC:
        Carac();
        break;
      case TRUE:
        True();
        break;
      case FALSE:
        False();
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void ValorBooleano() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
        True();
        break;
      case FALSE:
        False();
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

  static final public void OperadorAri() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SUMA:
        Suma();
        break;
      case RESTA:
        Resta();
        break;
      case MULTI:
        Multi();
        break;
      case DIVISION:
        Division();
        break;
      case RESIDUO:
        Residuo();
        break;
      case POTENCIA:
        Potencia();
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    } catch (TokenMgrError ex) {
        mensajesError.add(ex.getMessage());
    }
  }

//METODOS DE LOS TOKEN
  static final public void Main() throws ParseException {
    try {
      jj_consume_token(MAIN);
    } catch (ParseException e) {
         mensajesError.add(e.getMessage());
    }
  }

  static final public void Progr() throws ParseException {
    try {
      jj_consume_token(PROGR);
    } catch (ParseException e) {
         mensajesError.add(e.getMessage());
    }
  }

  static final public void Finprogr() throws ParseException {
    try {
      jj_consume_token(FINPROGR);
    } catch (ParseException e) {
         mensajesError.add(e.getMessage());
    }
  }

  static final public void Nprograma() throws ParseException {
    try {
      jj_consume_token(NPROGRAMA);
    } catch (ParseException e) {
         mensajesError.add(e.getMessage());
    }
  }

  static final public void Entrada1() throws ParseException {
    try {
      jj_consume_token(ENTRADA);
    } catch (ParseException e) {
         mensajesError.add(e.getMessage());
    }
  }

  static final public void Salida1() throws ParseException {
    try {
      jj_consume_token(SALIDA);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Variable() throws ParseException {
    try {
      jj_consume_token(VARIABLE);
    } catch (ParseException e) {
         mensajesError.add(e.getMessage());
    }
  }

  static final public void Numero() throws ParseException {
    try {
      jj_consume_token(NUMERO);
    } catch (ParseException e) {
         mensajesError.add(e.getMessage());
    }
  }

  static final public void Numerodec() throws ParseException {
    try {
      jj_consume_token(NUMERODEC);
    } catch (ParseException e) {
         mensajesError.add(e.getMessage());
    }
  }

  static final public void Carac() throws ParseException {
    try {
      jj_consume_token(CARAC);
    } catch (ParseException e) {
         mensajesError.add(e.getMessage());
    }
  }

  static final public void Cadena() throws ParseException {
    try {
      jj_consume_token(CADENA);
    } catch (ParseException e) {
         mensajesError.add(e.getMessage());
    }
  }

  static final public void Pari() throws ParseException {
    try {
      jj_consume_token(PARI);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Pard() throws ParseException {
    try {
      jj_consume_token(PARD);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Llai() throws ParseException {
    try {
      jj_consume_token(LLAI);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Llad() throws ParseException {
    try {
      jj_consume_token(LLAD);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Cori() throws ParseException {
    try {
      jj_consume_token(CORI);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Cord() throws ParseException {
    try {
      jj_consume_token(CORD);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Entero() throws ParseException {
    try {
      jj_consume_token(ENTERO);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Decimal() throws ParseException {
    try {
      jj_consume_token(DECIMAL);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Caracter() throws ParseException {
    try {
      jj_consume_token(CARACTER);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Cade() throws ParseException {
    try {
      jj_consume_token(CADE);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Booleano() throws ParseException {
    try {
      jj_consume_token(BOOLEANO);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Si() throws ParseException {
    try {
      jj_consume_token(SI);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Sino() throws ParseException {
    try {
      jj_consume_token(SINO);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Nosi() throws ParseException {
    try {
      jj_consume_token(NOSI);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Opcion() throws ParseException {
    try {
      jj_consume_token(OPCION);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Caso1() throws ParseException {
    try {
      jj_consume_token(CASO);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Interrumpir() throws ParseException {
    try {
      jj_consume_token(INTERRUMPIR);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void For1() throws ParseException {
    try {
      jj_consume_token(FOR);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void While1() throws ParseException {
    try {
      jj_consume_token(WHILE);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Do() throws ParseException {
    try {
      jj_consume_token(DO);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void True() throws ParseException {
    try {
      jj_consume_token(TRUE);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void False() throws ParseException {
    try {
      jj_consume_token(FALSE);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Opy() throws ParseException {
    try {
      jj_consume_token(OPY);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Opo() throws ParseException {
    try {
      jj_consume_token(OPO);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Menor() throws ParseException {
    try {
      jj_consume_token(MENOR);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Mayor() throws ParseException {
    try {
      jj_consume_token(MAYOR);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Igual() throws ParseException {
    try {
      jj_consume_token(IGUAL);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Diferentede() throws ParseException {
    try {
      jj_consume_token(DIFERENTEDE);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Dpuntos() throws ParseException {
    try {
      jj_consume_token(DPUNTOS);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Asignar() throws ParseException {
    try {
      jj_consume_token(ASIGNAR);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Menorigual() throws ParseException {
    try {
      jj_consume_token(MENORIGUAL);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Mayorigual() throws ParseException {
    try {
      jj_consume_token(MAYORIGUAL);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Pucoma() throws ParseException {
    try {
      jj_consume_token(PUCOMA);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
        hastaPucoma();
    }
  }

  static final public void Inc() throws ParseException {
    try {
      jj_consume_token(INC);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Dec() throws ParseException {
    try {
      jj_consume_token(DEC);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Dcomilla() throws ParseException {
    try {
      jj_consume_token(DCOMILLA);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Coma() throws ParseException {
    try {
      jj_consume_token(COMA);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Negacion() throws ParseException {
    try {
      jj_consume_token(NEGACION);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Suma() throws ParseException {
    try {
      jj_consume_token(SUMA);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Resta() throws ParseException {
    try {
      jj_consume_token(RESTA);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Multi() throws ParseException {
    try {
      jj_consume_token(MULTI);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Division() throws ParseException {
    try {
      jj_consume_token(DIVISION);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Residuo() throws ParseException {
    try {
      jj_consume_token(RESIDUO);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Potencia() throws ParseException {
    try {
      jj_consume_token(POTENCIA);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static final public void Pordefecto() throws ParseException {
    try {
      jj_consume_token(PORDEFECTO);
    } catch (ParseException e) {
        mensajesError.add(e.getMessage());
    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public AtroemTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[39];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x24000,0x1f800000,0x0,0xc0000,0xc4000,0x180,0x180,0x180,0x180,0x0,0x0,0x1000060,0x19e00,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x1000000,0x0,0x1000000,0x1000000,0x0,0x1000000,0x1000000,0x0,0x400000,0x60,0x1400060,0x1000000,0x0,0x1000060,0x60,0x1f800000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1f89f8,0x1f89f8,0x0,0x0,0x100018,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x200,0x1f00000,0x0,0x1000,0x4000,0x2000,0x1100000,0x0,0x1100000,0x18,0xf8,0x0,0x600000,0x1f00000,0x0,0x600000,0x700000,0x0,0x600000,0x0,0x0,0x1f00000,0x0,0x600000,0x1e00000,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public Atroem(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Atroem(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AtroemTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Atroem(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AtroemTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Atroem(AtroemTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(AtroemTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 39; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List jj_expentries = new java.util.ArrayList();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[61];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 39; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 61; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

        }
